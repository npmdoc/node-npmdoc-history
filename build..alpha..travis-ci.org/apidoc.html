<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/reacttraining/history#readme"

    >history (v4.6.1)</a>
</h1>
<h4>Manage session history with JavaScript</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.history">module history</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">history.</span>__esModule</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.createBrowserHistory">
            function <span class="apidocSignatureSpan">history.</span>createBrowserHistory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.createHashHistory">
            function <span class="apidocSignatureSpan">history.</span>createHashHistory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.createLocation">
            function <span class="apidocSignatureSpan">history.</span>createLocation
            <span class="apidocSignatureSpan">(path, state, key, currentLocation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.createMemoryHistory">
            function <span class="apidocSignatureSpan">history.</span>createMemoryHistory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.createPath">
            function <span class="apidocSignatureSpan">history.</span>createPath
            <span class="apidocSignatureSpan">(location)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.locationsAreEqual">
            function <span class="apidocSignatureSpan">history.</span>locationsAreEqual
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.parsePath">
            function <span class="apidocSignatureSpan">history.</span>parsePath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan"></span>history</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">history.</span>DOMUtils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">history.</span>LocationUtils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">history.</span>PathUtils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">history.</span>createTransitionManager</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.history.DOMUtils">module history.DOMUtils</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">history.DOMUtils.</span>__esModule</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">history.DOMUtils.</span>canUseDOM</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.DOMUtils.addEventListener">
            function <span class="apidocSignatureSpan">history.DOMUtils.</span>addEventListener
            <span class="apidocSignatureSpan">(node, event, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.DOMUtils.getConfirmation">
            function <span class="apidocSignatureSpan">history.DOMUtils.</span>getConfirmation
            <span class="apidocSignatureSpan">(message, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.DOMUtils.isExtraneousPopstateEvent">
            function <span class="apidocSignatureSpan">history.DOMUtils.</span>isExtraneousPopstateEvent
            <span class="apidocSignatureSpan">(event)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.DOMUtils.removeEventListener">
            function <span class="apidocSignatureSpan">history.DOMUtils.</span>removeEventListener
            <span class="apidocSignatureSpan">(node, event, listener)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.DOMUtils.supportsGoWithoutReloadUsingHash">
            function <span class="apidocSignatureSpan">history.DOMUtils.</span>supportsGoWithoutReloadUsingHash
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.DOMUtils.supportsHistory">
            function <span class="apidocSignatureSpan">history.DOMUtils.</span>supportsHistory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.DOMUtils.supportsPopStateOnHashChange">
            function <span class="apidocSignatureSpan">history.DOMUtils.</span>supportsPopStateOnHashChange
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.history.LocationUtils">module history.LocationUtils</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">history.LocationUtils.</span>__esModule</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.LocationUtils.createLocation">
            function <span class="apidocSignatureSpan">history.LocationUtils.</span>createLocation
            <span class="apidocSignatureSpan">(path, state, key, currentLocation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.LocationUtils.locationsAreEqual">
            function <span class="apidocSignatureSpan">history.LocationUtils.</span>locationsAreEqual
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.history.PathUtils">module history.PathUtils</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">history.PathUtils.</span>__esModule</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.PathUtils.addLeadingSlash">
            function <span class="apidocSignatureSpan">history.PathUtils.</span>addLeadingSlash
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.PathUtils.createPath">
            function <span class="apidocSignatureSpan">history.PathUtils.</span>createPath
            <span class="apidocSignatureSpan">(location)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.PathUtils.parsePath">
            function <span class="apidocSignatureSpan">history.PathUtils.</span>parsePath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.PathUtils.stripLeadingSlash">
            function <span class="apidocSignatureSpan">history.PathUtils.</span>stripLeadingSlash
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.PathUtils.stripPrefix">
            function <span class="apidocSignatureSpan">history.PathUtils.</span>stripPrefix
            <span class="apidocSignatureSpan">(path, prefix)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.PathUtils.stripTrailingSlash">
            function <span class="apidocSignatureSpan">history.PathUtils.</span>stripTrailingSlash
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.history.createBrowserHistory">module history.createBrowserHistory</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">history.createBrowserHistory.</span>__esModule</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.createBrowserHistory.default">
            function <span class="apidocSignatureSpan">history.createBrowserHistory.</span>default
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.history.createHashHistory">module history.createHashHistory</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">history.createHashHistory.</span>__esModule</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.createHashHistory.default">
            function <span class="apidocSignatureSpan">history.createHashHistory.</span>default
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.history.createMemoryHistory">module history.createMemoryHistory</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">history.createMemoryHistory.</span>__esModule</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.createMemoryHistory.default">
            function <span class="apidocSignatureSpan">history.createMemoryHistory.</span>default
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.history.createTransitionManager">module history.createTransitionManager</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">history.createTransitionManager.</span>__esModule</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.createTransitionManager.default">
            function <span class="apidocSignatureSpan">history.createTransitionManager.</span>default
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.history.history">module history.history</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">history.history.</span>__esModule</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.history.createBrowserHistory">
            function <span class="apidocSignatureSpan">history.history.</span>createBrowserHistory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.history.createHashHistory">
            function <span class="apidocSignatureSpan">history.history.</span>createHashHistory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.history.createLocation">
            function <span class="apidocSignatureSpan">history.history.</span>createLocation
            <span class="apidocSignatureSpan">(path, state, key, currentLocation)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.history.createMemoryHistory">
            function <span class="apidocSignatureSpan">history.history.</span>createMemoryHistory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.history.createPath">
            function <span class="apidocSignatureSpan">history.history.</span>createPath
            <span class="apidocSignatureSpan">(location)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.history.locationsAreEqual">
            function <span class="apidocSignatureSpan">history.history.</span>locationsAreEqual
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.history.history.parsePath">
            function <span class="apidocSignatureSpan">history.history.</span>parsePath
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.history" id="apidoc.module.history">module history</a></h1>




    <h2>
        <a href="#apidoc.element.history.createBrowserHistory" id="apidoc.element.history.createBrowserHistory">
        function <span class="apidocSignatureSpan">history.</span>createBrowserHistory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createBrowserHistory() {
  var props = arguments.length &#x3e; 0 &#x26;&#x26; arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, &#x27;Browser history needs a DOM&#x27;);

  var globalHistory = window.history;
  var canUseHistory = (0, _DOMUtils.supportsHistory)();
  var needsHashChangeListener = !(0, _DOMUtils.supportsPopStateOnHashChange)();

  var _props$forceRefresh = props.forceRefresh,
      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,
      _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : &#x27;&#x27;;

  var getDOMLocation = function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;


    var path = pathname + search + hash;

    if (basename) path = (0, _PathUtils.stripPrefix)(path, basename);

    return _extends({}, (0, _PathUtils.parsePath)(path), {
      state: state,
      key: key
    });
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var handlePopState = function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if ((0, _DOMUtils.isExtraneousPopstateEvent)(event)) return;

    handlePop(getDOMLocation(event.state));
  };

  var handleHashChange = function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  };

  var forceNextPop = false;

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = &#x27;POP&#x27;;

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of keys we&#x27;ve seen in sessionStorage.
    // Instead, we just default to 0 for keys we don&#x27;t know.

    var toIndex = allKeys.indexOf(toLocation.key);

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allKeys.indexOf(fromLocation.key);

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];

  // Public interface

  var createHref = function createHref(location) {
    return basename + (0, _PathUtils.createPath)(location);
  };

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === &#x27;undefined&#x27; ? &#x27;undefined&#x27; : _typeof(path)) === &#x27;object&#x27; &#x26;&#x26; path.state !== undefined
 &#x26;&#x26; state !== undefined), &#x27;You should avoid providing a 2nd state argument to push when the 1st &#x27; + &#x27;argument is a location-like
 object that already has state; it is ignored&#x27;);

    var action = &#x27;PUSH&#x27;;
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = l ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.history.createHashHistory" id="apidoc.element.history.createHashHistory">
        function <span class="apidocSignatureSpan">history.</span>createHashHistory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createHashHistory() {
  var props = arguments.length &#x3e; 0 &#x26;&#x26; arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, &#x27;Hash history needs a DOM&#x27;);

  var globalHistory = window.history;
  var canGoWithoutReload = (0, _DOMUtils.supportsGoWithoutReloadUsingHash)();

  var _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$hashType = props.hashType,
      hashType = _props$hashType === undefined ? &#x27;slash&#x27; : _props$hashType;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : &#x27;&#x27;;

  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;


  var getDOMLocation = function getDOMLocation() {
    var path = decodePath(getHashPath());

    if (basename) path = (0, _PathUtils.stripPrefix)(path, basename);

    return (0, _PathUtils.parsePath)(path);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var forceNextPop = false;
  var ignorePath = null;

  var handleHashChange = function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;

      if (!forceNextPop &#x26;&#x26; (0, _LocationUtils.locationsAreEqual)(prevLocation, location)) return; // A hashchange doesn&#x27;t always
 == location change.

      if (ignorePath === (0, _PathUtils.createPath)(location)) return; // Ignore this change; we already setState in push/replace
.

      ignorePath = null;

      handlePop(location);
    }
  };

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = &#x27;POP&#x27;;

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of paths we&#x27;ve seen in sessionStorage.
    // Instead, we just default to 0 for paths we don&#x27;t know.

    var toIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(toLocation));

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(fromLocation));

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  // Ensure the hash is encoded properly before doing anything else.
  var path = getHashPath();
  var encodedPath = encodePath(path);

  if (path !== encodedPath) replaceHashPath(encodedPath);

  var initialLocation = getDOMLocation();
  var allPaths = [(0, _PathUtils.createPath)(initialLocation)];

  // Public interface

  var createHref = function createHref(location) {
    return &#x27;#&#x27; + encodePath(basename + (0, _PathUtils.createPath)(location));
  };

  var push = function push(path, state) {
    (0, _warning2.default)(state === undefined, &#x27;Hash history cannot push state; it is ignored&#x27;);

    var action = &#x27;PUSH&#x27;;
    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = (0, _PathUtils.createPath)(location);
      var en ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.history.createLocation" id="apidoc.element.history.createLocation">
        function <span class="apidocSignatureSpan">history.</span>createLocation
        <span class="apidocSignatureSpan">(path, state, key, currentLocation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createLocation(path, state, key, currentLocation) {
  var location = void 0;
  if (typeof path === &#x27;string&#x27;) {
    // Two-arg form: push(path, state)
    location = (0, _PathUtils.parsePath)(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = _extends({}, path);

    if (location.pathname === undefined) location.pathname = &#x27;&#x27;;

    if (location.search) {
      if (location.search.charAt(0) !== &#x27;?&#x27;) location.search = &#x27;?&#x27; + location.search;
    } else {
      location.search = &#x27;&#x27;;
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== &#x27;#&#x27;) location.hash = &#x27;#&#x27; + location.hash;
    } else {
      location.hash = &#x27;&#x27;;
    }

    if (state !== undefined &#x26;&#x26; location.state === undefined) location.state = state;
  }

  location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== &#x27;/&#x27;) {
      location.pathname = (0, _resolvePathname2.default)(location.pathname, currentLocation.pathname);
    }
  }

  return location;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.history.createMemoryHistory" id="apidoc.element.history.createMemoryHistory">
        function <span class="apidocSignatureSpan">history.</span>createMemoryHistory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createMemoryHistory() {
  var props = arguments.length &#x3e; 0 &#x26;&#x26; arguments[0] !== undefined ? arguments[0] : {};
  var getUserConfirmation = props.getUserConfirmation,
      _props$initialEntries = props.initialEntries,
      initialEntries = _props$initialEntries === undefined ? [&#x27;/&#x27;] : _props$initialEntries,
      _props$initialIndex = props.initialIndex,
      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;


  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = history.entries.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === &#x27;string&#x27; ? (0, _LocationUtils.createLocation)(entry, undefined, createKey()) : (0, _LocationUtils.createLocation
)(entry, undefined, entry.key || createKey());
  });

  // Public interface

  var createHref = _PathUtils.createPath;

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === &#x27;undefined&#x27; ? &#x27;undefined&#x27; : _typeof(path)) === &#x27;object&#x27; &#x26;&#x26; path.state !== undefined
 &#x26;&#x26; state !== undefined), &#x27;You should avoid providing a 2nd state argument to push when the 1st &#x27; + &#x27;argument is a location-like
 object that already has state; it is ignored&#x27;);

    var action = &#x27;PUSH&#x27;;
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;

      var nextEntries = history.entries.slice(0);
      if (nextEntries.length &#x3e; nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(!((typeof path === &#x27;undefined&#x27; ? &#x27;undefined&#x27; : _typeof(path)) === &#x27;object&#x27; &#x26;&#x26; path.state !== undefined
 &#x26;&#x26; state !== undefined), &#x27;You should avoid providing a 2nd state argument to replace when the 1st &#x27; + &#x27;argument is a location-like
 object that already has state; it is ignored&#x27;);

    var action = &#x27;REPLACE&#x27;;
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      history.entries[history.index] = location;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);

    var action = &#x27;POP&#x27;;
    var location = history.entries[nextIndex];

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var canGo = function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex &#x3e;= 0 &#x26;&#x26; nextIndex &#x3c; history.entries.length;
  };

  var block = function block() {
    var prompt = arguments.length &#x3e; 0 &#x26;&#x26; arguments[0] !== undefined ? arguments[0] : false;
    return transitionManag ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.history.createPath" id="apidoc.element.history.createPath">
        function <span class="apidocSignatureSpan">history.</span>createPath
        <span class="apidocSignatureSpan">(location)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;


  var path = encodeURI(pathname || &#x27;/&#x27;);

  if (search &#x26;&#x26; search !== &#x27;?&#x27;) path += search.charAt(0) === &#x27;?&#x27; ? search : &#x27;?&#x27; + search;

  if (hash &#x26;&#x26; hash !== &#x27;#&#x27;) path += hash.charAt(0) === &#x27;#&#x27; ? hash : &#x27;#&#x27; + hash;

  return path;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.history.locationsAreEqual" id="apidoc.element.history.locationsAreEqual">
        function <span class="apidocSignatureSpan">history.</span>locationsAreEqual
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function locationsAreEqual(a, b) {
  return a.pathname === b.pathname &#x26;&#x26; a.search === b.search &#x26;&#x26; a.hash === b.hash &#x26;&#x26; a.key === b.key &#x26;&#x26; (0, _valueEqual2.default)(
a.state, b.state);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.history.parsePath" id="apidoc.element.history.parsePath">
        function <span class="apidocSignatureSpan">history.</span>parsePath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parsePath(path) {
  var pathname = path || &#x27;/&#x27;;
  var search = &#x27;&#x27;;
  var hash = &#x27;&#x27;;

  var hashIndex = pathname.indexOf(&#x27;#&#x27;);
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf(&#x27;?&#x27;);
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  pathname = decodeURI(pathname);

  return {
    pathname: pathname,
    search: search === &#x27;?&#x27; ? &#x27;&#x27; : search,
    hash: hash === &#x27;#&#x27; ? &#x27;&#x27; : hash
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>












</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.history.DOMUtils" id="apidoc.module.history.DOMUtils">module history.DOMUtils</a></h1>






    <h2>
        <a href="#apidoc.element.history.DOMUtils.addEventListener" id="apidoc.element.history.DOMUtils.addEventListener">
        function <span class="apidocSignatureSpan">history.DOMUtils.</span>addEventListener
        <span class="apidocSignatureSpan">(node, event, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addEventListener(node, event, listener) {
  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent(&#x27;on&#x27; + event, listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

&#x27;use strict&#x27;;

exports.__esModule = true;
var canUseDOM = exports.canUseDOM = !!(typeof window !== &#x27;undefined&#x27; &#x26;&#x26; window.document &#x26;&#x26; window.
document.createElement);

var addEventListener = exports.addEventListener = function addEventListener(node, event, listener) {
  return node.addEventListener ? node.<span class="apidocCodeKeywordSpan">addEventListener</span>(event, listener, false) : node
.attachEvent(&#x27;on&#x27; + event, listener);
};

var removeEventListener = exports.removeEventListener = function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent(&#x27;on&#x27; + event,
listener);
};

var getConfirmation = exports.getConfirmation = function getConfirmation(message, callback) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.history.DOMUtils.getConfirmation" id="apidoc.element.history.DOMUtils.getConfirmation">
        function <span class="apidocSignatureSpan">history.DOMUtils.</span>getConfirmation
        <span class="apidocSignatureSpan">(message, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getConfirmation(message, callback) {
  return callback(window.confirm(message));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.history.DOMUtils.isExtraneousPopstateEvent" id="apidoc.element.history.DOMUtils.isExtraneousPopstateEvent">
        function <span class="apidocSignatureSpan">history.DOMUtils.</span>isExtraneousPopstateEvent
        <span class="apidocSignatureSpan">(event)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isExtraneousPopstateEvent(event) {
  return event.state === undefined &#x26;&#x26; navigator.userAgent.indexOf(&#x27;CriOS&#x27;) === -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.history.DOMUtils.removeEventListener" id="apidoc.element.history.DOMUtils.removeEventListener">
        function <span class="apidocSignatureSpan">history.DOMUtils.</span>removeEventListener
        <span class="apidocSignatureSpan">(node, event, listener)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.removeEventListener(event, listener, false) : node.detachEvent(&#x27;on&#x27; + event, listener);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var canUseDOM = exports.canUseDOM = !!(typeof window !== &#x27;undefined&#x27; &#x26;&#x26; window.document &#x26;&#x26; window.
document.createElement);

var addEventListener = exports.addEventListener = function addEventListener(node, event, listener) {
  return node.addEventListener ? node.addEventListener(event, listener, false) : node.attachEvent(&#x27;on&#x27; + event, listener
);
};

var removeEventListener = exports.removeEventListener = function removeEventListener(node, event, listener) {
  return node.removeEventListener ? node.<span class="apidocCodeKeywordSpan">removeEventListener</span>(event, listener, false) :
node.detachEvent(&#x27;on&#x27; + event, listener);
};

var getConfirmation = exports.getConfirmation = function getConfirmation(message, callback) {
  return callback(window.confirm(message));
}; // eslint-disable-line no-alert

/**
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.history.DOMUtils.supportsGoWithoutReloadUsingHash" id="apidoc.element.history.DOMUtils.supportsGoWithoutReloadUsingHash">
        function <span class="apidocSignatureSpan">history.DOMUtils.</span>supportsGoWithoutReloadUsingHash
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function supportsGoWithoutReloadUsingHash() {
  return window.navigator.userAgent.indexOf(&#x27;Firefox&#x27;) === -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.history.DOMUtils.supportsHistory" id="apidoc.element.history.DOMUtils.supportsHistory">
        function <span class="apidocSignatureSpan">history.DOMUtils.</span>supportsHistory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function supportsHistory() {
  var ua = window.navigator.userAgent;

  if ((ua.indexOf(&#x27;Android 2.&#x27;) !== -1 || ua.indexOf(&#x27;Android 4.0&#x27;) !== -1) &#x26;&#x26; ua.indexOf(&#x27;Mobile Safari&#x27;) !== -1 &#x26;&#x26; ua.indexOf(&#x27;
Chrome&#x27;) === -1 &#x26;&#x26; ua.indexOf(&#x27;Windows Phone&#x27;) === -1) return false;

  return window.history &#x26;&#x26; &#x27;pushState&#x27; in window.history;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.history.DOMUtils.supportsPopStateOnHashChange" id="apidoc.element.history.DOMUtils.supportsPopStateOnHashChange">
        function <span class="apidocSignatureSpan">history.DOMUtils.</span>supportsPopStateOnHashChange
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function supportsPopStateOnHashChange() {
  return window.navigator.userAgent.indexOf(&#x27;Trident&#x27;) === -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.history.LocationUtils" id="apidoc.module.history.LocationUtils">module history.LocationUtils</a></h1>




    <h2>
        <a href="#apidoc.element.history.LocationUtils.createLocation" id="apidoc.element.history.LocationUtils.createLocation">
        function <span class="apidocSignatureSpan">history.LocationUtils.</span>createLocation
        <span class="apidocSignatureSpan">(path, state, key, currentLocation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createLocation(path, state, key, currentLocation) {
  var location = void 0;
  if (typeof path === &#x27;string&#x27;) {
    // Two-arg form: push(path, state)
    location = (0, _PathUtils.parsePath)(path);
    location.state = state;
  } else {
    // One-arg form: push(location)
    location = _extends({}, path);

    if (location.pathname === undefined) location.pathname = &#x27;&#x27;;

    if (location.search) {
      if (location.search.charAt(0) !== &#x27;?&#x27;) location.search = &#x27;?&#x27; + location.search;
    } else {
      location.search = &#x27;&#x27;;
    }

    if (location.hash) {
      if (location.hash.charAt(0) !== &#x27;#&#x27;) location.hash = &#x27;#&#x27; + location.hash;
    } else {
      location.hash = &#x27;&#x27;;
    }

    if (state !== undefined &#x26;&#x26; location.state === undefined) location.state = state;
  }

  location.key = key;

  if (currentLocation) {
    // Resolve incomplete/relative pathname relative to current location.
    if (!location.pathname) {
      location.pathname = currentLocation.pathname;
    } else if (location.pathname.charAt(0) !== &#x27;/&#x27;) {
      location.pathname = (0, _resolvePathname2.default)(location.pathname, currentLocation.pathname);
    }
  }

  return location;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.history.LocationUtils.locationsAreEqual" id="apidoc.element.history.LocationUtils.locationsAreEqual">
        function <span class="apidocSignatureSpan">history.LocationUtils.</span>locationsAreEqual
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function locationsAreEqual(a, b) {
  return a.pathname === b.pathname &#x26;&#x26; a.search === b.search &#x26;&#x26; a.hash === b.hash &#x26;&#x26; a.key === b.key &#x26;&#x26; (0, _valueEqual2.default)(
a.state, b.state);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.history.PathUtils" id="apidoc.module.history.PathUtils">module history.PathUtils</a></h1>




    <h2>
        <a href="#apidoc.element.history.PathUtils.addLeadingSlash" id="apidoc.element.history.PathUtils.addLeadingSlash">
        function <span class="apidocSignatureSpan">history.PathUtils.</span>addLeadingSlash
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function addLeadingSlash(path) {
  return path.charAt(0) === &#x27;/&#x27; ? path : &#x27;/&#x27; + path;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.history.PathUtils.createPath" id="apidoc.element.history.PathUtils.createPath">
        function <span class="apidocSignatureSpan">history.PathUtils.</span>createPath
        <span class="apidocSignatureSpan">(location)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createPath(location) {
  var pathname = location.pathname,
      search = location.search,
      hash = location.hash;


  var path = encodeURI(pathname || &#x27;/&#x27;);

  if (search &#x26;&#x26; search !== &#x27;?&#x27;) path += search.charAt(0) === &#x27;?&#x27; ? search : &#x27;?&#x27; + search;

  if (hash &#x26;&#x26; hash !== &#x27;#&#x27;) path += hash.charAt(0) === &#x27;#&#x27; ? hash : &#x27;#&#x27; + hash;

  return path;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.history.PathUtils.parsePath" id="apidoc.element.history.PathUtils.parsePath">
        function <span class="apidocSignatureSpan">history.PathUtils.</span>parsePath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parsePath(path) {
  var pathname = path || &#x27;/&#x27;;
  var search = &#x27;&#x27;;
  var hash = &#x27;&#x27;;

  var hashIndex = pathname.indexOf(&#x27;#&#x27;);
  if (hashIndex !== -1) {
    hash = pathname.substr(hashIndex);
    pathname = pathname.substr(0, hashIndex);
  }

  var searchIndex = pathname.indexOf(&#x27;?&#x27;);
  if (searchIndex !== -1) {
    search = pathname.substr(searchIndex);
    pathname = pathname.substr(0, searchIndex);
  }

  pathname = decodeURI(pathname);

  return {
    pathname: pathname,
    search: search === &#x27;?&#x27; ? &#x27;&#x27; : search,
    hash: hash === &#x27;#&#x27; ? &#x27;&#x27; : hash
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.history.PathUtils.stripLeadingSlash" id="apidoc.element.history.PathUtils.stripLeadingSlash">
        function <span class="apidocSignatureSpan">history.PathUtils.</span>stripLeadingSlash
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stripLeadingSlash(path) {
  return path.charAt(0) === &#x27;/&#x27; ? path.substr(1) : path;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.history.PathUtils.stripPrefix" id="apidoc.element.history.PathUtils.stripPrefix">
        function <span class="apidocSignatureSpan">history.PathUtils.</span>stripPrefix
        <span class="apidocSignatureSpan">(path, prefix)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stripPrefix(path, prefix) {
  return path.indexOf(prefix) === 0 ? path.substr(prefix.length) : path;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.history.PathUtils.stripTrailingSlash" id="apidoc.element.history.PathUtils.stripTrailingSlash">
        function <span class="apidocSignatureSpan">history.PathUtils.</span>stripTrailingSlash
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function stripTrailingSlash(path) {
  return path.charAt(path.length - 1) === &#x27;/&#x27; ? path.slice(0, -1) : path;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.history.createBrowserHistory" id="apidoc.module.history.createBrowserHistory">module history.createBrowserHistory</a></h1>




    <h2>
        <a href="#apidoc.element.history.createBrowserHistory.default" id="apidoc.element.history.createBrowserHistory.default">
        function <span class="apidocSignatureSpan">history.createBrowserHistory.</span>default
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createBrowserHistory() {
  var props = arguments.length &#x3e; 0 &#x26;&#x26; arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, &#x27;Browser history needs a DOM&#x27;);

  var globalHistory = window.history;
  var canUseHistory = (0, _DOMUtils.supportsHistory)();
  var needsHashChangeListener = !(0, _DOMUtils.supportsPopStateOnHashChange)();

  var _props$forceRefresh = props.forceRefresh,
      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,
      _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : &#x27;&#x27;;

  var getDOMLocation = function getDOMLocation(historyState) {
    var _ref = historyState || {},
        key = _ref.key,
        state = _ref.state;

    var _window$location = window.location,
        pathname = _window$location.pathname,
        search = _window$location.search,
        hash = _window$location.hash;


    var path = pathname + search + hash;

    if (basename) path = (0, _PathUtils.stripPrefix)(path, basename);

    return _extends({}, (0, _PathUtils.parsePath)(path), {
      state: state,
      key: key
    });
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var handlePopState = function handlePopState(event) {
    // Ignore extraneous popstate events in WebKit.
    if ((0, _DOMUtils.isExtraneousPopstateEvent)(event)) return;

    handlePop(getDOMLocation(event.state));
  };

  var handleHashChange = function handleHashChange() {
    handlePop(getDOMLocation(getHistoryState()));
  };

  var forceNextPop = false;

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = &#x27;POP&#x27;;

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of keys we&#x27;ve seen in sessionStorage.
    // Instead, we just default to 0 for keys we don&#x27;t know.

    var toIndex = allKeys.indexOf(toLocation.key);

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allKeys.indexOf(fromLocation.key);

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  var initialLocation = getDOMLocation(getHistoryState());
  var allKeys = [initialLocation.key];

  // Public interface

  var createHref = function createHref(location) {
    return basename + (0, _PathUtils.createPath)(location);
  };

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === &#x27;undefined&#x27; ? &#x27;undefined&#x27; : _typeof(path)) === &#x27;object&#x27; &#x26;&#x26; path.state !== undefined
 &#x26;&#x26; state !== undefined), &#x27;You should avoid providing a 2nd state argument to push when the 1st &#x27; + &#x27;argument is a location-like
 object that already has state; it is ignored&#x27;);

    var action = &#x27;PUSH&#x27;;
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var href = createHref(location);
      var key = l ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.history.createHashHistory" id="apidoc.module.history.createHashHistory">module history.createHashHistory</a></h1>




    <h2>
        <a href="#apidoc.element.history.createHashHistory.default" id="apidoc.element.history.createHashHistory.default">
        function <span class="apidocSignatureSpan">history.createHashHistory.</span>default
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createHashHistory() {
  var props = arguments.length &#x3e; 0 &#x26;&#x26; arguments[0] !== undefined ? arguments[0] : {};

  (0, _invariant2.default)(_DOMUtils.canUseDOM, &#x27;Hash history needs a DOM&#x27;);

  var globalHistory = window.history;
  var canGoWithoutReload = (0, _DOMUtils.supportsGoWithoutReloadUsingHash)();

  var _props$getUserConfirm = props.getUserConfirmation,
      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
      _props$hashType = props.hashType,
      hashType = _props$hashType === undefined ? &#x27;slash&#x27; : _props$hashType;

  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : &#x27;&#x27;;

  var _HashPathCoders$hashT = HashPathCoders[hashType],
      encodePath = _HashPathCoders$hashT.encodePath,
      decodePath = _HashPathCoders$hashT.decodePath;


  var getDOMLocation = function getDOMLocation() {
    var path = decodePath(getHashPath());

    if (basename) path = (0, _PathUtils.stripPrefix)(path, basename);

    return (0, _PathUtils.parsePath)(path);
  };

  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = globalHistory.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var forceNextPop = false;
  var ignorePath = null;

  var handleHashChange = function handleHashChange() {
    var path = getHashPath();
    var encodedPath = encodePath(path);

    if (path !== encodedPath) {
      // Ensure we always have a properly-encoded hash.
      replaceHashPath(encodedPath);
    } else {
      var location = getDOMLocation();
      var prevLocation = history.location;

      if (!forceNextPop &#x26;&#x26; (0, _LocationUtils.locationsAreEqual)(prevLocation, location)) return; // A hashchange doesn&#x27;t always
 == location change.

      if (ignorePath === (0, _PathUtils.createPath)(location)) return; // Ignore this change; we already setState in push/replace
.

      ignorePath = null;

      handlePop(location);
    }
  };

  var handlePop = function handlePop(location) {
    if (forceNextPop) {
      forceNextPop = false;
      setState();
    } else {
      var action = &#x27;POP&#x27;;

      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
        if (ok) {
          setState({ action: action, location: location });
        } else {
          revertPop(location);
        }
      });
    }
  };

  var revertPop = function revertPop(fromLocation) {
    var toLocation = history.location;

    // TODO: We could probably make this more reliable by
    // keeping a list of paths we&#x27;ve seen in sessionStorage.
    // Instead, we just default to 0 for paths we don&#x27;t know.

    var toIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(toLocation));

    if (toIndex === -1) toIndex = 0;

    var fromIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(fromLocation));

    if (fromIndex === -1) fromIndex = 0;

    var delta = toIndex - fromIndex;

    if (delta) {
      forceNextPop = true;
      go(delta);
    }
  };

  // Ensure the hash is encoded properly before doing anything else.
  var path = getHashPath();
  var encodedPath = encodePath(path);

  if (path !== encodedPath) replaceHashPath(encodedPath);

  var initialLocation = getDOMLocation();
  var allPaths = [(0, _PathUtils.createPath)(initialLocation)];

  // Public interface

  var createHref = function createHref(location) {
    return &#x27;#&#x27; + encodePath(basename + (0, _PathUtils.createPath)(location));
  };

  var push = function push(path, state) {
    (0, _warning2.default)(state === undefined, &#x27;Hash history cannot push state; it is ignored&#x27;);

    var action = &#x27;PUSH&#x27;;
    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var path = (0, _PathUtils.createPath)(location);
      var en ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.history.createMemoryHistory" id="apidoc.module.history.createMemoryHistory">module history.createMemoryHistory</a></h1>




    <h2>
        <a href="#apidoc.element.history.createMemoryHistory.default" id="apidoc.element.history.createMemoryHistory.default">
        function <span class="apidocSignatureSpan">history.createMemoryHistory.</span>default
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createMemoryHistory() {
  var props = arguments.length &#x3e; 0 &#x26;&#x26; arguments[0] !== undefined ? arguments[0] : {};
  var getUserConfirmation = props.getUserConfirmation,
      _props$initialEntries = props.initialEntries,
      initialEntries = _props$initialEntries === undefined ? [&#x27;/&#x27;] : _props$initialEntries,
      _props$initialIndex = props.initialIndex,
      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,
      _props$keyLength = props.keyLength,
      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;


  var transitionManager = (0, _createTransitionManager2.default)();

  var setState = function setState(nextState) {
    _extends(history, nextState);

    history.length = history.entries.length;

    transitionManager.notifyListeners(history.location, history.action);
  };

  var createKey = function createKey() {
    return Math.random().toString(36).substr(2, keyLength);
  };

  var index = clamp(initialIndex, 0, initialEntries.length - 1);
  var entries = initialEntries.map(function (entry) {
    return typeof entry === &#x27;string&#x27; ? (0, _LocationUtils.createLocation)(entry, undefined, createKey()) : (0, _LocationUtils.createLocation
)(entry, undefined, entry.key || createKey());
  });

  // Public interface

  var createHref = _PathUtils.createPath;

  var push = function push(path, state) {
    (0, _warning2.default)(!((typeof path === &#x27;undefined&#x27; ? &#x27;undefined&#x27; : _typeof(path)) === &#x27;object&#x27; &#x26;&#x26; path.state !== undefined
 &#x26;&#x26; state !== undefined), &#x27;You should avoid providing a 2nd state argument to push when the 1st &#x27; + &#x27;argument is a location-like
 object that already has state; it is ignored&#x27;);

    var action = &#x27;PUSH&#x27;;
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      var prevIndex = history.index;
      var nextIndex = prevIndex + 1;

      var nextEntries = history.entries.slice(0);
      if (nextEntries.length &#x3e; nextIndex) {
        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
      } else {
        nextEntries.push(location);
      }

      setState({
        action: action,
        location: location,
        index: nextIndex,
        entries: nextEntries
      });
    });
  };

  var replace = function replace(path, state) {
    (0, _warning2.default)(!((typeof path === &#x27;undefined&#x27; ? &#x27;undefined&#x27; : _typeof(path)) === &#x27;object&#x27; &#x26;&#x26; path.state !== undefined
 &#x26;&#x26; state !== undefined), &#x27;You should avoid providing a 2nd state argument to replace when the 1st &#x27; + &#x27;argument is a location-like
 object that already has state; it is ignored&#x27;);

    var action = &#x27;REPLACE&#x27;;
    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (!ok) return;

      history.entries[history.index] = location;

      setState({ action: action, location: location });
    });
  };

  var go = function go(n) {
    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);

    var action = &#x27;POP&#x27;;
    var location = history.entries[nextIndex];

    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
      if (ok) {
        setState({
          action: action,
          location: location,
          index: nextIndex
        });
      } else {
        // Mimic the behavior of DOM histories by
        // causing a render after a cancelled POP.
        setState();
      }
    });
  };

  var goBack = function goBack() {
    return go(-1);
  };

  var goForward = function goForward() {
    return go(1);
  };

  var canGo = function canGo(n) {
    var nextIndex = history.index + n;
    return nextIndex &#x3e;= 0 &#x26;&#x26; nextIndex &#x3c; history.entries.length;
  };

  var block = function block() {
    var prompt = arguments.length &#x3e; 0 &#x26;&#x26; arguments[0] !== undefined ? arguments[0] : false;
    return transitionManag ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.history.createTransitionManager" id="apidoc.module.history.createTransitionManager">module history.createTransitionManager</a></h1>




    <h2>
        <a href="#apidoc.element.history.createTransitionManager.default" id="apidoc.element.history.createTransitionManager.default">
        function <span class="apidocSignatureSpan">history.createTransitionManager.</span>default
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createTransitionManager() {
  var prompt = null;

  var setPrompt = function setPrompt(nextPrompt) {
    (0, _warning2.default)(prompt == null, &#x27;A history supports only one prompt at a time&#x27;);

    prompt = nextPrompt;

    return function () {
      if (prompt === nextPrompt) prompt = null;
    };
  };

  var confirmTransitionTo = function confirmTransitionTo(location, action, getUserConfirmation, callback) {
    // TODO: If another transition starts while we&#x27;re still confirming
    // the previous one, we may end up in a weird state. Figure out the
    // best way to handle this.
    if (prompt != null) {
      var result = typeof prompt === &#x27;function&#x27; ? prompt(location, action) : prompt;

      if (typeof result === &#x27;string&#x27;) {
        if (typeof getUserConfirmation === &#x27;function&#x27;) {
          getUserConfirmation(result, callback);
        } else {
          (0, _warning2.default)(false, &#x27;A history needs a getUserConfirmation function in order to use a prompt message&#x27;);

          callback(true);
        }
      } else {
        // Return false from a transition hook to cancel the transition.
        callback(result !== false);
      }
    } else {
      callback(true);
    }
  };

  var listeners = [];

  var appendListener = function appendListener(fn) {
    var isActive = true;

    var listener = function listener() {
      if (isActive) fn.apply(undefined, arguments);
    };

    listeners.push(listener);

    return function () {
      isActive = false;
      listeners = listeners.filter(function (item) {
        return item !== listener;
      });
    };
  };

  var notifyListeners = function notifyListeners() {
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key &#x3c; _len; _key++) {
      args[_key] = arguments[_key];
    }

    listeners.forEach(function (listener) {
      return listener.apply(undefined, args);
    });
  };

  return {
    setPrompt: setPrompt,
    confirmTransitionTo: confirmTransitionTo,
    appendListener: appendListener,
    notifyListeners: notifyListeners
  };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.history.history" id="apidoc.module.history.history">module history.history</a></h1>




    <h2>
        <a href="#apidoc.element.history.history.createBrowserHistory" id="apidoc.element.history.history.createBrowserHistory">
        function <span class="apidocSignatureSpan">history.history.</span>createBrowserHistory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createBrowserHistory() {
	  var props = arguments.length &#x3e; 0 &#x26;&#x26; arguments[0] !== undefined ? arguments[0] : {};

	  !_DOMUtils.canUseDOM ?  false ? (0, _invariant2.default)(false, &#x27;Browser history needs a DOM&#x27;) : (0, _invariant2.default)(false
) : void 0;

	  var globalHistory = window.history;
	  var canUseHistory = (0, _DOMUtils.supportsHistory)();
	  var needsHashChangeListener = !(0, _DOMUtils.supportsPopStateOnHashChange)();

	  var _props$forceRefresh = props.forceRefresh,
	      forceRefresh = _props$forceRefresh === undefined ? false : _props$forceRefresh,
	      _props$getUserConfirm = props.getUserConfirmation,
	      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
	      _props$keyLength = props.keyLength,
	      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;

	  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : &#x27;&#x27;;

	  var getDOMLocation = function getDOMLocation(historyState) {
	    var _ref = historyState || {},
	        key = _ref.key,
	        state = _ref.state;

	    var _window$location = window.location,
	        pathname = _window$location.pathname,
	        search = _window$location.search,
	        hash = _window$location.hash;


	    var path = pathname + search + hash;

	    if (basename) path = (0, _PathUtils.stripPrefix)(path, basename);

	    return _extends({}, (0, _PathUtils.parsePath)(path), {
	      state: state,
	      key: key
	    });
	  };

	  var createKey = function createKey() {
	    return Math.random().toString(36).substr(2, keyLength);
	  };

	  var transitionManager = (0, _createTransitionManager2.default)();

	  var setState = function setState(nextState) {
	    _extends(history, nextState);

	    history.length = globalHistory.length;

	    transitionManager.notifyListeners(history.location, history.action);
	  };

	  var handlePopState = function handlePopState(event) {
	    // Ignore extraneous popstate events in WebKit.
	    if ((0, _DOMUtils.isExtraneousPopstateEvent)(event)) return;

	    handlePop(getDOMLocation(event.state));
	  };

	  var handleHashChange = function handleHashChange() {
	    handlePop(getDOMLocation(getHistoryState()));
	  };

	  var forceNextPop = false;

	  var handlePop = function handlePop(location) {
	    if (forceNextPop) {
	      forceNextPop = false;
	      setState();
	    } else {
	      var action = &#x27;POP&#x27;;

	      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
	        if (ok) {
	          setState({ action: action, location: location });
	        } else {
	          revertPop(location);
	        }
	      });
	    }
	  };

	  var revertPop = function revertPop(fromLocation) {
	    var toLocation = history.location;

	    // TODO: We could probably make this more reliable by
	    // keeping a list of keys we&#x27;ve seen in sessionStorage.
	    // Instead, we just default to 0 for keys we don&#x27;t know.

	    var toIndex = allKeys.indexOf(toLocation.key);

	    if (toIndex === -1) toIndex = 0;

	    var fromIndex = allKeys.indexOf(fromLocation.key);

	    if (fromIndex === -1) fromIndex = 0;

	    var delta = toIndex - fromIndex;

	    if (delta) {
	      forceNextPop = true;
	      go(delta);
	    }
	  };

	  var initialLocation = getDOMLocation(getHistoryState());
	  var allKeys = [initialLocation.key];

	  // Public interface

	  var createHref = function createHref(location) {
	    return basename + (0, _PathUtils.createPath)(location);
	  };

	  var push = function push(path, state) {
	     false ? (0, _warning2.default)(!((typeof path === &#x27;undefined&#x27; ? &#x27;undefined&#x27; : _typeof(path)) === &#x27;object&#x27; &#x26;&#x26; path.state !==
undefined &#x26;&#x26; state !== undefined), &#x27;You should avoid providing a 2nd state argument to push when the 1st &#x27; + &#x27;argument is a location
-like object that already has state; it is ignored&#x27;) : void 0;

	    var action = &#x27;PUSH&#x27;;
	    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

	    transit ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.history.history.createHashHistory" id="apidoc.element.history.history.createHashHistory">
        function <span class="apidocSignatureSpan">history.history.</span>createHashHistory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createHashHistory() {
	  var props = arguments.length &#x3e; 0 &#x26;&#x26; arguments[0] !== undefined ? arguments[0] : {};

	  !_DOMUtils.canUseDOM ?  false ? (0, _invariant2.default)(false, &#x27;Hash history needs a DOM&#x27;) : (0, _invariant2.default)(false) :
void 0;

	  var globalHistory = window.history;
	  var canGoWithoutReload = (0, _DOMUtils.supportsGoWithoutReloadUsingHash)();

	  var _props$getUserConfirm = props.getUserConfirmation,
	      getUserConfirmation = _props$getUserConfirm === undefined ? _DOMUtils.getConfirmation : _props$getUserConfirm,
	      _props$hashType = props.hashType,
	      hashType = _props$hashType === undefined ? &#x27;slash&#x27; : _props$hashType;

	  var basename = props.basename ? (0, _PathUtils.stripTrailingSlash)((0, _PathUtils.addLeadingSlash)(props.basename)) : &#x27;&#x27;;

	  var _HashPathCoders$hashT = HashPathCoders[hashType],
	      encodePath = _HashPathCoders$hashT.encodePath,
	      decodePath = _HashPathCoders$hashT.decodePath;


	  var getDOMLocation = function getDOMLocation() {
	    var path = decodePath(getHashPath());

	    if (basename) path = (0, _PathUtils.stripPrefix)(path, basename);

	    return (0, _PathUtils.parsePath)(path);
	  };

	  var transitionManager = (0, _createTransitionManager2.default)();

	  var setState = function setState(nextState) {
	    _extends(history, nextState);

	    history.length = globalHistory.length;

	    transitionManager.notifyListeners(history.location, history.action);
	  };

	  var forceNextPop = false;
	  var ignorePath = null;

	  var handleHashChange = function handleHashChange() {
	    var path = getHashPath();
	    var encodedPath = encodePath(path);

	    if (path !== encodedPath) {
	      // Ensure we always have a properly-encoded hash.
	      replaceHashPath(encodedPath);
	    } else {
	      var location = getDOMLocation();
	      var prevLocation = history.location;

	      if (!forceNextPop &#x26;&#x26; (0, _LocationUtils.locationsAreEqual)(prevLocation, location)) return; // A hashchange doesn&#x27;t always
 == location change.

	      if (ignorePath === (0, _PathUtils.createPath)(location)) return; // Ignore this change; we already setState in push/replace
.

	      ignorePath = null;

	      handlePop(location);
	    }
	  };

	  var handlePop = function handlePop(location) {
	    if (forceNextPop) {
	      forceNextPop = false;
	      setState();
	    } else {
	      var action = &#x27;POP&#x27;;

	      transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
	        if (ok) {
	          setState({ action: action, location: location });
	        } else {
	          revertPop(location);
	        }
	      });
	    }
	  };

	  var revertPop = function revertPop(fromLocation) {
	    var toLocation = history.location;

	    // TODO: We could probably make this more reliable by
	    // keeping a list of paths we&#x27;ve seen in sessionStorage.
	    // Instead, we just default to 0 for paths we don&#x27;t know.

	    var toIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(toLocation));

	    if (toIndex === -1) toIndex = 0;

	    var fromIndex = allPaths.lastIndexOf((0, _PathUtils.createPath)(fromLocation));

	    if (fromIndex === -1) fromIndex = 0;

	    var delta = toIndex - fromIndex;

	    if (delta) {
	      forceNextPop = true;
	      go(delta);
	    }
	  };

	  // Ensure the hash is encoded properly before doing anything else.
	  var path = getHashPath();
	  var encodedPath = encodePath(path);

	  if (path !== encodedPath) replaceHashPath(encodedPath);

	  var initialLocation = getDOMLocation();
	  var allPaths = [(0, _PathUtils.createPath)(initialLocation)];

	  // Public interface

	  var createHref = function createHref(location) {
	    return &#x27;#&#x27; + encodePath(basename + (0, _PathUtils.createPath)(location));
	  };

	  var push = function push(path, state) {
	     false ? (0, _warning2.default)(state === undefined, &#x27;Hash history cannot push state; it is ignored&#x27;) : void 0;

	    var action = &#x27;PUSH&#x27;;
	    var location = (0, _LocationUtils.createLocation)(path, undefined, undefined, history.location);

	    transitionManager.c ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.history.history.createLocation" id="apidoc.element.history.history.createLocation">
        function <span class="apidocSignatureSpan">history.history.</span>createLocation
        <span class="apidocSignatureSpan">(path, state, key, currentLocation)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createLocation(path, state, key, currentLocation) {
	  var location = void 0;
	  if (typeof path === &#x27;string&#x27;) {
	    // Two-arg form: push(path, state)
	    location = (0, _PathUtils.parsePath)(path);
	    location.state = state;
	  } else {
	    // One-arg form: push(location)
	    location = _extends({}, path);

	    if (location.pathname === undefined) location.pathname = &#x27;&#x27;;

	    if (location.search) {
	      if (location.search.charAt(0) !== &#x27;?&#x27;) location.search = &#x27;?&#x27; + location.search;
	    } else {
	      location.search = &#x27;&#x27;;
	    }

	    if (location.hash) {
	      if (location.hash.charAt(0) !== &#x27;#&#x27;) location.hash = &#x27;#&#x27; + location.hash;
	    } else {
	      location.hash = &#x27;&#x27;;
	    }

	    if (state !== undefined &#x26;&#x26; location.state === undefined) location.state = state;
	  }

	  location.key = key;

	  if (currentLocation) {
	    // Resolve incomplete/relative pathname relative to current location.
	    if (!location.pathname) {
	      location.pathname = currentLocation.pathname;
	    } else if (location.pathname.charAt(0) !== &#x27;/&#x27;) {
	      location.pathname = (0, _resolvePathname2.default)(location.pathname, currentLocation.pathname);
	    }
	  }

	  return location;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.history.history.createMemoryHistory" id="apidoc.element.history.history.createMemoryHistory">
        function <span class="apidocSignatureSpan">history.history.</span>createMemoryHistory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createMemoryHistory() {
	  var props = arguments.length &#x3e; 0 &#x26;&#x26; arguments[0] !== undefined ? arguments[0] : {};
	  var getUserConfirmation = props.getUserConfirmation,
	      _props$initialEntries = props.initialEntries,
	      initialEntries = _props$initialEntries === undefined ? [&#x27;/&#x27;] : _props$initialEntries,
	      _props$initialIndex = props.initialIndex,
	      initialIndex = _props$initialIndex === undefined ? 0 : _props$initialIndex,
	      _props$keyLength = props.keyLength,
	      keyLength = _props$keyLength === undefined ? 6 : _props$keyLength;


	  var transitionManager = (0, _createTransitionManager2.default)();

	  var setState = function setState(nextState) {
	    _extends(history, nextState);

	    history.length = history.entries.length;

	    transitionManager.notifyListeners(history.location, history.action);
	  };

	  var createKey = function createKey() {
	    return Math.random().toString(36).substr(2, keyLength);
	  };

	  var index = clamp(initialIndex, 0, initialEntries.length - 1);
	  var entries = initialEntries.map(function (entry) {
	    return typeof entry === &#x27;string&#x27; ? (0, _LocationUtils.createLocation)(entry, undefined, createKey()) : (0, _LocationUtils.createLocation
)(entry, undefined, entry.key || createKey());
	  });

	  // Public interface

	  var createHref = _PathUtils.createPath;

	  var push = function push(path, state) {
	     false ? (0, _warning2.default)(!((typeof path === &#x27;undefined&#x27; ? &#x27;undefined&#x27; : _typeof(path)) === &#x27;object&#x27; &#x26;&#x26; path.state !==
undefined &#x26;&#x26; state !== undefined), &#x27;You should avoid providing a 2nd state argument to push when the 1st &#x27; + &#x27;argument is a location
-like object that already has state; it is ignored&#x27;) : void 0;

	    var action = &#x27;PUSH&#x27;;
	    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

	    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
	      if (!ok) return;

	      var prevIndex = history.index;
	      var nextIndex = prevIndex + 1;

	      var nextEntries = history.entries.slice(0);
	      if (nextEntries.length &#x3e; nextIndex) {
	        nextEntries.splice(nextIndex, nextEntries.length - nextIndex, location);
	      } else {
	        nextEntries.push(location);
	      }

	      setState({
	        action: action,
	        location: location,
	        index: nextIndex,
	        entries: nextEntries
	      });
	    });
	  };

	  var replace = function replace(path, state) {
	     false ? (0, _warning2.default)(!((typeof path === &#x27;undefined&#x27; ? &#x27;undefined&#x27; : _typeof(path)) === &#x27;object&#x27; &#x26;&#x26; path.state !==
undefined &#x26;&#x26; state !== undefined), &#x27;You should avoid providing a 2nd state argument to replace when the 1st &#x27; + &#x27;argument is a location
-like object that already has state; it is ignored&#x27;) : void 0;

	    var action = &#x27;REPLACE&#x27;;
	    var location = (0, _LocationUtils.createLocation)(path, state, createKey(), history.location);

	    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
	      if (!ok) return;

	      history.entries[history.index] = location;

	      setState({ action: action, location: location });
	    });
	  };

	  var go = function go(n) {
	    var nextIndex = clamp(history.index + n, 0, history.entries.length - 1);

	    var action = &#x27;POP&#x27;;
	    var location = history.entries[nextIndex];

	    transitionManager.confirmTransitionTo(location, action, getUserConfirmation, function (ok) {
	      if (ok) {
	        setState({
	          action: action,
	          location: location,
	          index: nextIndex
	        });
	      } else {
	        // Mimic the behavior of DOM histories by
	        // causing a render after a cancelled POP.
	        setState();
	      }
	    });
	  };

	  var goBack = function goBack() {
	    return go(-1);
	  };

	  var goForward = function goForward() {
	    return go(1);
	  };

	  var canGo = function canGo(n) {
	    var nextIndex = history.index + n;
	    return nextIndex &#x3e;= 0 &#x26;&#x26; nextIndex &#x3c; history.entries.length;
	  };

	  var block = function block() ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.history.history.createPath" id="apidoc.element.history.history.createPath">
        function <span class="apidocSignatureSpan">history.history.</span>createPath
        <span class="apidocSignatureSpan">(location)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function createPath(location) {
	  var pathname = location.pathname,
	      search = location.search,
	      hash = location.hash;


	  var path = encodeURI(pathname || &#x27;/&#x27;);

	  if (search &#x26;&#x26; search !== &#x27;?&#x27;) path += search.charAt(0) === &#x27;?&#x27; ? search : &#x27;?&#x27; + search;

	  if (hash &#x26;&#x26; hash !== &#x27;#&#x27;) path += hash.charAt(0) === &#x27;#&#x27; ? hash : &#x27;#&#x27; + hash;

	  return path;
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.history.history.locationsAreEqual" id="apidoc.element.history.history.locationsAreEqual">
        function <span class="apidocSignatureSpan">history.history.</span>locationsAreEqual
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function locationsAreEqual(a, b) {
	  return a.pathname === b.pathname &#x26;&#x26; a.search === b.search &#x26;&#x26; a.hash === b.hash &#x26;&#x26; a.key === b.key &#x26;&#x26; (0, _valueEqual2.default
)(a.state, b.state);
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.history.history.parsePath" id="apidoc.element.history.history.parsePath">
        function <span class="apidocSignatureSpan">history.history.</span>parsePath
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parsePath(path) {
	  var pathname = path || &#x27;/&#x27;;
	  var search = &#x27;&#x27;;
	  var hash = &#x27;&#x27;;

	  var hashIndex = pathname.indexOf(&#x27;#&#x27;);
	  if (hashIndex !== -1) {
	    hash = pathname.substr(hashIndex);
	    pathname = pathname.substr(0, hashIndex);
	  }

	  var searchIndex = pathname.indexOf(&#x27;?&#x27;);
	  if (searchIndex !== -1) {
	    search = pathname.substr(searchIndex);
	    pathname = pathname.substr(0, searchIndex);
	  }

	  pathname = decodeURI(pathname);

	  return {
	    pathname: pathname,
	    search: search === &#x27;?&#x27; ? &#x27;&#x27; : search,
	    hash: hash === &#x27;#&#x27; ? &#x27;&#x27; : hash
	  };
	}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
